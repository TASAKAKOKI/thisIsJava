스레드 상태 제어
	:실행 중인 스레드의 상태를 변경하는 것을 말한다

	상태 변화를 가져오는 메소드의 종류
		생성 	->	실행대기
			new			: 스레드를 생성하여, 실행대기 상태로 만든다.
			
		일시정지	-> 	실행대기
			interrupt()	: 일시정지 상태에서 interrupt()가 호출되면 InterruptedException 발생
			notify()	: 동기화메소드 또는 동기화블록에서만 호출가능한 Object의 메소드(즉, 모든 객체가 가지고 있는 메소드)
			notifyAll()	: 동기화메소드 또는 동기화블록에서만 호출가능한 Object의 메소드(즉, 모든 객체가 가지고 있는 메소드) 
			
		실행대기	->	실행
			CPU의 스케줄러에 의해 선택되면, 실행됨
			실행 중 시간할당량이 다 되면, 실행대기상태로 이동
	
			yield()		: 시간할당량이 다 되기 전에, yield()를 호출하면 즉시 실행대기상태가 된다.
						: 동일 또는 높은 우선순위를 가진 다른 스레드가 있다면, 그 스레드가 먼저 실행되게 한다.
						: 주로 무의미한 반복을 하지 않고, 다른 스레드가 실행될 수 있도록 해줄 때 사용.
						
		실행		->	일시정지
			sleep()		: 주어진 시간(ms)동안 일시정지 상태가 된후, 실행대기상태로 변한다.
			join()		: 호출한 스레드가 종료될 때까지 실행 중이던 스레드가 일시정지가 된후, 호출한 스레드가 종료되면 실행대기상태가 된다.
						: 계산 작업을 하는 스레드가 모든 계산 작업을 마쳤을 때, 계산 결과값을 받아 이용하는 경우에 주로 사용한다.
			wait()		: ***동기화메소드 또는 동기화블록에서만 호출가능한 Object의 메소드(즉, 모든 객체가 가지고 있는 메소드)***
						: 호출되면, 스레드는 일시정지상태가 된다.
						: Waiting Pool에서 스레드가 관리된다. 이때, 자기 스스로는 절대 실행대기상태로 갈 수 없다.
			    		: 다른 스레드가 notify()혹은 notifyAll()을 호출해야만 일시정지가 풀리고 실행대기상태가 된다.
			wait(long timeout)				:	notify()가 호출되지 않아도 시간이 지나면 스레드가 자동적으로 실행대기 상태가 된다.
			wait(long timeout, int nanos)	:	notify()가 호출되지 않아도 시간이 지나면 스레드가 자동적으로 실행대기 상태가 된다.
						: wait()메소드들은 두개의 스레드가 교대로 번갈아가며 (공유객체를 사용할 때 등) 실행해야 할 경우에 주로 사용
						
		실행		->	종료
			stop()	:메소드를 호출하면 강제 종료가 되지만, deprecated되었다.
			
			스레드의 안전한 종료 : stop플래그, interrupt()를 사용
				: 경우에 따라서는 실행 중인 스레드를 즉시 종료할 필요가 있는 경우 사용
				stop()메소드의 사용
					스레드를 즉시 종료 시킨다.
					스레드를 갑자기 종료하게 되면 사용 중이던 자원들이 불안전한 상태로 남겨지므로,
					deprecated되었다.
					
				stop플래그를 사용하는 방법
					stop플래그로 메소드의 정상 종료를 유도한다.
					stop이라는 boolean타입의 stop플래그 필드를 생성하여,
					while문을 stop값에 따라 종료가 되도록 코드 작성
				
				interrupt()메소드를 이용하는 방법
					일시정지 상태일 경우 InterruptedException을 발생시킴
					try catch문에서 sleep()등으로 스레드가 일시정지 중일때, interrupt()가 호출되면, catch문으로 예외를 넘기게 된다.
				
					실행대기 또는 실행상태에서는 InterruptedException이 발생하지 않는다.
						이떄, interrupt()메소드가 호출되면, 스레드가 일시정지상태가 되야 예외가 발생한다.
						
					일시정지 상태로 만들지 않고, while문을 빠져나오는 방법
						interrupted()정적메소드 또는 isInterrupted()인스턴스 메소드를 호출하여, boolean값을 얻어, if문으로 while문을 빠져나오도록 코드를 작성할 수 있다.
							while(true) {
								System.out.println("실행 중");
								if(Thread.interrupted()) {
									break;
								}
							}
							
		동기화 메소드 또는 동기화블록에서만 사용가능한 메소드는
			wait(), notify(), notifyAll()이다.